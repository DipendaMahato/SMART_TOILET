/**
 * This ruleset enforces a strict user-ownership security model for a "Smart Toilet App".
 *
 * Core Philosophy:
 * All user data, including profiles, health metrics, and generated insights, is considered
 * private and is accessible only by the authenticated user who owns the data. There are
 * no public or shared collections. The default security posture is to deny all access
 * unless explicitly granted to the document owner.
 *
 * Data Structure:
 * All data is segregated and nested under a user-specific path: `/users/{userId}`.
 *   - /users/{userId}: Stores the user's core profile (`UserProfile`).
 *   - /users/{userId}/healthData/{healthDataId}: A subcollection for raw sensor data (`HealthData`).
 *   - /users/{userId}/healthInsights/{healthInsightId}: A subcollection for AI-generated insights (`HealthInsight`).
 * This hierarchical structure makes ownership clear and security rules simple and performant.
 *
 * Key Security Decisions:
 * - Strict Ownership: Access to any document or subcollection under `/users/{userId}` is
 *   granted only if the requester's authenticated UID matches the `{userId}` in the path.
 * - No User Listing: It is forbidden to query the top-level `/users` collection to prevent
 *   exposing a list of all application users.
 * - Path/Data Consistency: On creation, rules validate that internal ID fields (e.g.,
 *   `UserProfile.id`, `HealthData.userId`) match the user ID from the document path to
 *   ensure relational integrity. These fields are immutable on update.
 * - Prototyping Flexibility: While authorization and ownership are strictly enforced,
 *   the specific shapes and data types of documents are not validated, allowing for
 *   rapid development and iteration on the data model.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the requesting user's UID matches the provided userId.
     * This is the primary function for checking document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the user is the owner AND the document already exists.
     * Used for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that a new UserProfile is being created by its owner and that
     * the internal 'id' field matches the user's auth UID for consistency.
     */
    function isCreatingOwnProfile(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }

    /**
     * Validates that a user is updating their own profile and ensures the
     * primary 'id' field cannot be changed after creation.
     */
    function isUpdatingOwnProfile() {
      // The final merged document must have the same ID as the original.
      return request.resource.data.id == resource.data.id;
    }
    
    /**
     * Validates that a new subcollection document (e.g., HealthData) has an
     * internal 'userId' field that matches the owner's ID from the path.
     */
    function isCreatingConsistentSubdocument(userId) {
      return isOwner(userId) && request.resource.data.userId == userId;
    }

    /**
     * Validates that the 'userId' field in a subcollection document is immutable.
     */
    function isImmutableOwnerLink() {
      // The final merged document must have the same userId as the original.
      return request.resource.data.userId == resource.data.userId;
    }


    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Manages user profile documents. Only the owner can create,
     * read, update, or delete their own profile. Listing all users is forbidden.
     * @path /users/{userId}
     * @allow (create) An authenticated user creating their own profile document, where
     *   `request.auth.uid` matches `{userId}`.
     * @allow (get) An authenticated user retrieving their own profile document.
     * @deny (list) Any user, authenticated or not, attempting to list all documents
     *   in the `/users` collection.
     * @deny (update) A user trying to modify another user's profile.
     * @principle Restricts access to a user's own data tree and enforces self-creation.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isCreatingOwnProfile(userId);
      allow update: if isExistingOwner(userId) && isUpdatingOwnProfile();
      allow delete: if isExistingOwner(userId);

      /**
       * @description Manages a user's private health data records. Access is
       * granted only to the user who owns the parent profile document.
       * @path /users/{userId}/healthData/{healthDataId}
       * @allow (list) The user listing all of their own health data records.
       * @allow (create) The user creating a new health data record for themselves.
       * @deny (get) A user trying to read a specific health record belonging to another user.
       * @deny (delete) A user trying to delete another user's health record.
       * @principle Enforces strict ownership for sensitive, user-specific subcollections.
       */
      match /healthData/{healthDataId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isCreatingConsistentSubdocument(userId);
        allow update: if isExistingOwner(userId) && isImmutableOwnerLink();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Manages AI-generated health insights for a user. Access is
       * restricted to the user who owns the parent profile document.
       * @path /users/{userId}/healthInsights/{healthInsightId}
       * @allow (list) The user listing all of their own health insights.
       * @allow (create) The user creating a new health insight for themselves.
       * @deny (get) A user trying to read a specific insight belonging to another user.
       * @deny (delete) A user trying to delete another user's insight.
       * @principle Enforces strict ownership for sensitive, user-specific subcollections.
       */
      match /healthInsights/{healthInsightId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isCreatingConsistentSubdocument(userId);
        allow update: if isExistingOwner(userId) && isImmutableOwnerLink();
        allow delete: if isExistingOwner(userId);
      }
      
      /**
       * @description Manages a user's real-time notifications and alerts.
       * Users can read their own notifications and mark them as read.
       * Creation is handled by client-side logic listening to sensor data.
       * @path /users/{userId}/notifications/{notificationId}
       * @allow (list) The user listing their own notifications.
       * @allow (get) The user reading a single notification.
       * @allow (create) The client creating a new notification for the user.
       * @allow (update) The user marking a notification as read.
       * @principle Enforces strict ownership for notifications.
       */
      match /notifications/{notificationId} {
        allow get, list, create: if isOwner(userId);
        allow update: if isExistingOwner(userId) && isImmutableOwnerLink();
        allow delete: if isExistingOwner(userId);
      }
    }
  }
}
